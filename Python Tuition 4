大家好，前面几期中，我们已经共同学习掌握了Python的一些基本语法，
这一期我们将一起来学习一些三个简单算法的实现。
第一个是 猜测和验证算法：Guess and Check
第二个是 在猜测和验证算法基础上改进得到的 近似算法
第三个是 二分法

首先我们来看一下 猜测和验证算法（Guess and Check）
实际上这个算法就是我们常说的穷举法，给定一个问题，首先猜测一个问题的答案，
然后去验证猜测的答案是否正确。如此循环往复，直到找到问题的答案或者穷举了所有的结果。
我们用猜测和验证算法来验证一个数是否是完全立方数，如果是的话，我们输出他的根。
所谓完全立方数，是指当一个整数a如果是另一个整数b的立方，那么就称这个数a为完全立方数，也叫做立方数。

例如 8 = 2^3。8就是个完全立方，他的根是2.

我们先简单看一下这个算法的基本原理。
例如我们要判断整数x是否是一个完全平方数，这里x可能为负数
为了方便我们代码实现。
在我们判定之前，我们先取x的绝对值，最后如果x是负数的话再在前面加个负号就可以了。
在python里面，对一一个数 x，我们使用命令。abs(x)获取他的绝对值。
首先，我们确定枚举的范围，我们知道，一个数的立方根一定不会大于这个数，
所以我们先简单确定我们的枚举范围的 0 - x的绝对值。
我先从0开始枚举，先计算0的3次方，这里 如果0的三次方小于x的绝对值，我们就继续枚举下一个整数
也就是1，同样的，如果1的三次方小于x的绝对值，我们就再往下枚举。
以此类推。当我们枚举到一个数值a，a的三次方等于x的绝对值了，那这个时候我们就找到了x的根
同时也可以确定x是一个完全立方数。
这时，如果x的负数，那么 我们输出他的根为 -a。否则就直接输出a。
当然，还有一种情况是，我们枚举到的这个a，他的三次方大于x的绝对值了。这就说明，x不是一个完全立方数。
因为a-1的三次方大于x的绝对值，a的三次方小于x的绝对值，而x的根又是整数，所以这样的整数是不存在的。

达到上面两种条件后，我们就可以停止枚举了。
当x是完全立方数的时候，在代码中，我们可以使用break语句，提前结束枚举。

下面我们在spyder里面看一下代码的实现。

cube = int(input("Please enter a number:"))
for guess in range(abs(cube)+1):
    if guess**3 >= abs(cube):
        break
if guess**3 != abs(cube):
    print("cube is not a perfect cube!")
else:
    if cube < 0:
        guess = -guess
    print("The root of", cube, "is", guess)
    
首先我们请求用户输入一个数，并将其强制类型转换为整数。
然后通过for循环来试图遍历所有可能的答案，因为用户的输入有可能是负数，所以我们这里使用 abs(cube)来取cube的绝对值。
当我们试到一个数，这个数的立方比给定的数大或者与之相等时，我们停止穷举，通过break跳出for循环。

然后判定我们最后一次的猜测结果的立方是与给定值相等还是不等。
如果不等的话，我们输出这个数不是一个完全立方数的提示。
如果相等，我们首先判定一下用户的输入是否是负数，
如果是，我们在猜测的值前加一个负号，然后输出，否则的直接输出结果。

我们来运行验证一下。

接下来我们来看一下第2个算法：近似算法，
有时候，当我们采用猜测验证算法去穷举一个问题的解时，有可能要穷举无穷多个。
这在代码里显然是不现实的。于是就有了在猜测验证算法基础上改进的近似算法。
也是通过枚举的形式，但是我们在枚举的时候会设定一个步长和一个误差范围。
当我们去枚举答案的时候，我们设定一个步长，
此外，我们再设定一个允许的误差范围。当我们的结果在这个允许的误差范围内时，停止穷举。

我们以求一个给定数值的立方根为例：
首先我们还是先来看一下原理。

这个时候，因为我们要求解的结果可能是一个无限小数，不肯能吧结果枚举出来。
但是我们可以或者一个近似的解，只要我们猜测的结果在误差允许犯范围内。我们就认为我们找到了答案。
例如，我可以设置误差范围的 epsilon，当我们枚举到一个数a，如果a^3和给定数值的差值小于epsilon，
我们就认为已经找到了答案。
我们枚举的时候，还是从0开始，对于给定数值x，我们枚举到x的绝对值结束。
然后我们设定一个步长，比如我们设定为0.0001.，枚举的时候每次增加0.0001.
同样的，我们先计算0的三次方，与x的绝对值比较，如果0的三次方与x的绝对值的差值大于epsilon，那么继续下一步。
当我们枚举到a时，第一次出现a的三次方等于与x的绝对值差值小于epsilon时，我们的枚举提前停止
然后判断如果x是负数，那么输出我们计算得到的根为-a，否则为a。
如果一直没有出现a的三次方等于与x的绝对值差值小于epsilon，当我们枚举到x的绝对值这个数时，枚举结束。
说明我们没有找到给定数值的根。

下面我们看一下代码实现。
cube = int(input("Please enter a number:"))
epsilon = 0.001
guess = 0.0
increment = 0.0001
num_guess = 0
while abs(guess**3 - abs(cube)) >= epsilon and guess <= abs(cube):
    guess = guess + increment
    num_guess += 1
print("num_guess=", num_guess)
if abs(guess**3 - abs(cube)) >= epsilon:
    print("Fail on cube root of", cube)
else:
    if cube < 0:
        guess = -guess
    print(guess,"is close to the cube root of", cube)
 
 首先请求用户输入输入一个数字，并将其强制类型转换成整数型。
 然后设定允许误差，这里我设置成0.001，
 然后我们设定穷举的步长为 0.0001
 我们在设定一个计数器，来计算我穷举的次数。
 因为这里是不确定次数的循环，所以我们使用while循环。
 进入循环的条件我们设置成误差大于我们允许误差值，同时我们猜测的结果不大于设定的数本身。
 每进入一次循环我给猜测值增加一个步长的大小，同时成猜测次数计数器加1.
跳出循环后，我们先输出猜测的次数，然后现在会有两种情况，一种是我们的猜测结果仍然不在误差范围内，但是猜测的值到了上限。
这种情况下我们输出猜测失败的消息。
另一种情况是猜测结果在误差范围内，我先判定用户输入的值是否是负数，让输出结果。

我们运行验证一下。输入34，得到结果是
Please enter a number:34
num_guess= 32396
3.239600000002412 is close to the cube root of 34
猜测了32396次，找到了一个误差范围内的根。
有些时候，我们会发现，输入一个较小的数，但是算法找不到他的根，这种情况可能是我们步长设置的太大了。

我们的枚举的时候，结果始终没有在误差范围内。
例如，我们第一步枚举的结果，出现在了epsilon左侧，下一次，跳到了右侧，这样就一直找不到答案。

使用猜测和验证算法时，我们需要一个个数值穷举，有些情况下会很浪费时间，下面我们再来看一个算法，二分法。
二分法是将问题所有可能的解先分为两部分，然后判断解在哪一个部分。
下一步再将包含解的那一部分分成两部分，判断解在哪一部分，
以此类推，直到找到期望的解。
下面我以计算给定整数的立方根为例来看一下二分法的代码实现

我们还是先来看一下原理。
如果我们想通过二分法找到一个给定数数值 x。
首先我们大致确定x的范围，例如我们知道x是在a和b之间的。
然后我们取a和b的中间值与x比较，如果中间值大于x，
我们就可以确定x在这个a与中间值之间，
入如果中间值小于x，那么我们可以确定x在中间值和b之间。
下一步再取新范围的中间值与x比较，以此类推，直到找到x。

接下来，我们结合近似算法，使用二分法来求解一个给定数值的根。
cube = float(input("Please enter a number:"))
epsilon = 0.0001
num_guesses = 0
low = 0
high = abs(cube)
guess = (low + high)/2.0
while abs(guess**3 - abs(cube)) >= epsilon :
    if guess**3 < abs(cube):
        low = guess
    else:
        high = guess
    guess = (low + high)/2.0
    num_guesses += 1
if cube < 0:
    guess = -guess
print("num_guess =", num_guesses)
print(guess,"is close to the root of", cube)

我们首先请求用户输入。然后定义误差范围，设置一个计数器来记我们的计算次数。
然后我们的结果是一定是介于0和这个值之间的，所以我们这设置二分法的边界为0到 这个数
然后取中间值，
接下我们用循环完成计算和边界的更新。
如果当前结果比值小，我们就更新边界的下界为当前的边界的中间值
反之，我们就更新上届为当前边界的中间值。
得到新的边界之后，我们再取他的中间值，进入下一个周期的循环运算，直到我们找到误差范围内的结果。
最后我们输出结果。

需要注意的是，二分法只适用于待求解的函数是单调函数的情况。

另外，我们刚才的算法不适用于计算 < 1 的数值的立方根。 
对于 <1 的情况，我们只需要调整一下边界条件就可以了。
cube = float(input("Please enter a number:"))
epsilon = 0.0001
num_guesses = 0
if abs(cube) >= 1:
    low = 0
    high = abs(cube)
else:
    low = abs(cube)
    high = 1
guess = (low + high)/2.0
while abs(guess**3 - abs(cube)) >= epsilon :
    if guess**3 < abs(cube):
        low = guess
    else:
        high = guess
    guess = (low + high)/2.0
    num_guesses += 1
if cube < 0:
    guess = -guess
print("num_guess =", num_guesses)
print(guess,"is close to the root of", cube)
