上一期我们介绍了字符串的一些操作，条件语句，和循环语句的基本用法
这一期我们继续来学习下更多关于字符串的操作，和循环语句

首先我们再来看几个关于字符串的操作。
第一个是 len(),我们使用len(s)可以返回字符串s中字符的个数。
例如
s = "abc"
len(s)

Out[1]: 3
第二个是对于字符串s，我们可以通过 s[i]来索引s中的字符。
例如
s = "abc"
s中有三个字符，python会给这三个字符从坐向右从0开始编号。
当我们执行索引命令时：
s[0] 获取从左向右第一个字符 a
s[1] 获取从左向右第二个字符 b
s[2] 获取从左向右第三个字符 c
s[3] 因为s只有三个字符，所以这里会报错

我们还可以从右向左索引，python会给字符串中的字符从右向左编号为-1，-2，-3 ...
还是上面那个s = “abc”
当我执行索引命令：
s[-1] 获取从右向左第一个字符 c
s[-2] 获取从右向左第二个字符 b
s[-3] 获取从右向左第三个字符 a
s[-4] 报错

有时候我们需要索引子字符串，而不是一个单个的字符，这个时候我们可以用下面这种方法，
s[start:stop:step] 从s编号为start的字符开始，步长step个字符，一直取到编号为stop-1的字符
或者
s[start:stop] 从s编号为start的字符开始，步长1个字符，一直取到编号为stop-1的字符
此外这里的 start,  stop, step也可以缺省，
如果写成
s[::],这个等价于s[0:len(s):1],也就是直接从左向右索引s
s[::-1]，这个等价于s[-1, -(len(s)+1),-1],也就是从右向左索引s
下面我们在spyder里看几个例子，
首先赋值
s = "abcdefghi"
我们通过
len(s)
可以看到s包含 9个字符
通过
s[3:6]
可以得到s从左向右，编号3到编号5的字符组成的这样一个子字符串，
a是第0个，第三个是d，第3+1=4个是e，第4+1=5个是f，也就是
def
通过
s[3:6:2]
可以得到s从左向右，编号3开始，步长1个字符到编号 5的字符结束，
也就是第3个d和第3+2=5个f，结果是
df
如果我们输入
s[::]
得到的的就是s本身
abcdefghi
如果我们输入
s[::-1]
得到的是s的逆序字符串，也就是
ihgfedcba
如果我们输入
s[4:1:-2]
可以得到从标号4的e开始，向左，步长为-2，到编号0前一个也就是编号1的位置1，这些字符组成的字符串，
也就是编号4的e,编号4-2 =2的c，再索引的话就是2-2=0超出了我们定义的范围，所以结果是
ec
需要注意的是，字符串中的字符是不可以被修改的，例如
s = "hello"
下面这个命令
s[0] = “H”
是会报错的。
如果我们想修改 s 中的第0个字符，
我们可以先索引s的第1个到最后一个字符，
然后在前面连接上我们要修改的字符，再重新赋值给s：
s = "H" + s[1:len(s)]

上一期我们介绍的for循环是在一串连续的整数序列中迭代，实际上，for循环的用法远不止如此，
我们还可以让for循环在 字符串上迭代。

下面我们来比较两端代码
s = "abcdefgh"
for index in range(len(s)):
    if s[index] == "i" or s[index] == "u":
        print("There is an i or u")
    
s = "abcdefgh"
for char in s:
    if char == "i" or char == "u":
        print("There is an i or u")
这两段代码实现相同的功能，判断字符串s中是否有字符i或者字符u，有的话就输出一段字符串。
第一种方法是用我们上一期的学习的for循环的方法，先定义一个范围，然后去索引。
在python中，我们还可以使用第二种方法，
命令
for char in s:
会将s中的字符作为一个迭代范围，从左向右一次索引并赋值给符号 char，让在下面的代码块中调用。

很明显，下面一种方法会使我们的代码看起来更容易理解。这种方法对条件语句if同样适用。

下面我们用基于字符串迭代的for循环来编写一段代码。
首先要求用户输入一个单词 word，然后输入这个单词出现的次数 times，
程序首先分别输出单词中的字母，然后把再把这个单词输出 times 次。
an_letters = "aefhilmnorsxAEFHILMNORSX"
word = input("Give me a word: ")
times = int(input("How many times do you want me to output? "))
for char in word:
    if char in an_letters:
        print("Give me an",char,"!",char)
    else:
        print("Give me a", char,"!",char)
print("What does that spell?")
for i in range(times):
    print(word,"!!!")
首先我们定义一个由所有发音由原音开头的字符组成的字符串。
然后请求用户输入一个单词，再请求用户输入一个数字，将输入结果强制类型转换成整数型。
然后for循环，对输入单词中的每一个字母，如果发音是以原音开头的，我们输出 "Give me an",char,"!",char
否则输出 "Give me a", char,"!",char
循环结束后，再把这个单词连续输出times次。
运行一下，当我们分别输入ITClassroom 和 6 时，输出的结果是
Give me a word: ITClassroom

How many times do you want me to output? 6
Give me an I ! I
Give me a T ! T
Give me a C ! C
Give me an l ! l
Give me an a ! a
Give me an s ! s
Give me an s ! s
Give me an r ! r
Give me an o ! o
Give me an o ! o
Give me an m ! m
What does that spell?
ITClassroom !!!
ITClassroom !!!
ITClassroom !!!
ITClassroom !!!
ITClassroom !!!
ITClassroom !!！

掌握了这些基本用法，下面我们来一起看一下使用python实现简单的算法：
首先我们来看一下 猜测和验证算法（Guess and Check）
实际上这个算法就是我们常说的穷举法，给定一个问题，首先猜测一个问题的答案，
然后去验证猜测的答案是否正确。如此循环往复，知道找到问题的答案或者穷举了所有的结果。
我们用猜测和验证算法来验证一个数是否是完全立方数，如果是的话，我们输出他的根。
所谓完全立方数，是指当一个整数如果是另一个整数的完全立方，那么就称这个数为完全立方数，也叫做立方数。

我们知道这个数的根一定不会大大于这个数本身，所以我们从0开始穷举，直到穷举到答案或者超出这个数的范围。
cube = int(input("Please enter a number:"))
for guess in range(abs(cube)+1):
    if guess**3 >= abs(cube):
        break
if guess**3 != abs(cube):
    print("cube is not a perfect cube!")
else:
    if cube < 0:
        guess = -guess
    print("The root of", cube, "is", guess)
首先我们请求用户输入一个数，并将其强制类型转换为整数。
然后通过for循环来试图遍历所有可能的答案，因为用户的输入有可能是负数，所以我们这里使用 abs(cube)来取cube的绝对值。
当我们试到一个数，这个数的立方比给定的数大或者与之相等时，我们停止穷举，通过break跳出for循环。

然后判定我们最后一次的猜测结果的立方是与给定值相等还是不等。
如果不等的话，我们输出这个数不是一个完全立方数的提示。
如果相等，我们首先判定一下用户的输入是否是负数，
如果是，我们在猜测的值前加一个负号，然后输出，否则的直接输出结果。

接下来我们来看一下第2个算法：近似算法，
有时候，当我们去穷举一个问题的解时，有可能要穷举无穷多个。
这在代码里显然是不现实的。于是就有了近似算法。
当我们去枚举答案的时候，我们设定一个步长，
此外，我们再设定一个允许的误差范围。当我们的结果在这个允许的误差范围内时，停止穷举。
我们以求一个给定数值的立方根为例：

cube = int(input("Please enter a number:"))
epsilon = 0.001
guess = 0.0
increment = 0.0001
num_guess = 0
while abs(guess**3 - abs(cube)) >= epsilon and guess <= abs(cube):
    guess = guess + increment
    num_guess += 1
print("num_guess=", num_guess)
if abs(guess**3 - abs(cube)) >= epsilon:
    print("Fail on cube root of", cube)
else:
    if cube < 0:
        guess = -guess
    print(guess,"is close to the cube root of", cube)
 
 首先请求用户输入输入一个数字，并将其强制类型转换成整数型。
 然后设定允许误差，这里我设置成0.001，
 然后我们设定穷举的步长为 0.0001
 我们在设定一个计数器，来计算我穷举的次数。
 因为这里是不确定次数的循环，所以我们使用while循环。
 进入循环的条件我们设置成误差大于我们允许误差值，同时我们猜测的结果不大于设定的数本身。
 每进入一次循环我给猜测值增加一个步长的大小，同时成猜测次数计数器加1.
跳出循环后，我们先输出猜测的次数，然后现在会有两种情况，一种是我们的猜测结果仍然不在误差范围内，但是猜测的值到了上限。
这种情况下我们输出猜测失败的消息。
另一种情况是猜测结果在误差范围内，我先判定用户输入的值是否是负数，让输出结果。

我们运行验证一下。输入34，得到结果是
Please enter a number:34
num_guess= 32396
3.239600000002412 is close to the cube root of 34
猜测了32396次，找到了一个误差范围内的根。
有些时候，我们我们会发现，输入一个较小的数，但是算法找不到他的根，这种情况可能是我们步长设置的太大了。
【例子】...

使用猜测和验证算法时，我们需要一个个数值穷举，有些情况下会很浪费时间，下面我们再来看一个算法，二分法。
二分法是将问题所有可能的解先分为两部分，然后判断解在哪一个部分。
下一步再将包含解的那一部分分成两部分，判断解在哪一部分，
以此类推，直到找到期望的解。
下面我以计算给定整数的立方根为例来看一下二分法的代码实现



将问题
将问题的

