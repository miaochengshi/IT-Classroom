上一期，我我们一起学习了两种复合数据类型，元组和列表。
元组是不可以被修改的，而列表是可以被修改的。
这一期，我们一起来学习递归(Recursion)和字典操作(Dictionary)

所谓递归，就是不断地重复同一个操作的过程。
从算法上来讲，递归是将一个规模较大的问题
简化为同样的但是规模较小的问题并解决。

我们先来看一个简单的例子，计算两个数 a和b的乘积：a*b
这个运算等价于我们将 b 个 a 相加，也就是
   a*b 
  =a + a + ... + a. (这里一共有b个a)
 下面我们再将是个表达式做一个简单的变换，
 我们还可以继续写成下面这个形式：
   a*b 
  =a + a + ... + a. (这里一共有b个a)
  =a + (a + ... + a). (这里一共有b个a)
  =a + a*(b-1) 
 也就是先计算 b-1 个 a 相加的结果，再在此基础上加上一个 a
 
 实际上，这就是一个递归的过程，将 b 个a相加的问题
 简化为b-1个a相加的问题，
 这时，我们需要计算 a*(b-1)，我们将这个问题继续简化为
 a+a*(b-2)
 以此类推，直到问题变成最基础的问题，也就是可以直接解决的形式，
 也就是 b=1 时， 此时 a*b = a
 
 我们可以用一个函数来描述这个递归的过程。
 def mult(a, b):
    if b == 1:
        return a
    else:
        return a + mult(a, b-1)
 我们定义函数 mult用递归的方法计算两个数的乘积，
 当 b=1 时，问题简化为最基础的问题，可以直接计算的形式，此时我们返回 a
 否则，我们将问题简化,返回
 a+mult(a+b)
 继续调用递归函数，计算更简单的问题。
 
那么什么样的问题才是最基础的问题呢？
我们再来看一个例子，计算一个给定数的阶乘，n!,我们知道
n! = n*(n-1)*(n-2)* ... *2*1
当 n=1 的时候，n的阶乘就是它本身，所以我们把 n=1作为最基础的问题
当我们用函数实现时，可以写成
def fac(n):
    if n == 1:
        return 1
    else:
        return n*fac(n-1)

 例如我们需要计算并输出3的阶乘，我们可以输入
 print(fac(3))
 
 变量空间的变化

我们再来看一个例子，汉诺塔问题。

有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：
1. 每次只能移动一个圆盘；
2. 大盘不能叠在小盘上面。
提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。

对于这个问题，我们可以用递归的思想解决。

目标是把这些盘全部移到 C 塔。那么先把 A 塔顶部的 N-1 块盘移动到 B 塔，
再把 A 塔剩下的大盘移到 C，最后把 B 塔的N-1块盘移到 C。
至于如何移动N-1快盘，我们可以用相同的方法，
先移动最上面N-2块盘，
如此递归下去。当我们需要移动的顶部盘块中只有一个圆盘时，我就找到了简化的最基础的问题，
此时，我们把这一个圆盘直接移到目标杆，也就是C杆。

下面我们来看一下如何在Python中用代码实现。

def printMove(fr, to):
    print("Move from", str(fr), "to", str(to))
    
def Towers(n, fr, to, spare):
    if n ==1:
        printMove(fr, to)
    else:
        Towers(n-1, fr, spare, to)
        Towers(1, fr, to, spare)
        Towers(n-1, spare, to, fr)
        
首先我们定义一个函数printMove用来输出我们每一步移动的过程
printMove(fr, to)表示将圆盘从fr对应的杆子移动到 to对应的杆子。

然后我们定义递归函数 Towers。函数中有四个参数
第一个位置的参数表示需要移动的圆盘的个数，
第二个位置的参数表示待移动圆盘或圆盘块现在在的位置，我们叫它当前位置，
第三个位置的参数表示目标杆的位置，我们叫它目标目标位置，
最后一个位置的参数表示剩下的一个杆子，我们叫它过渡位置。
首先我们设置基础问题的解，当需要移动的圆盘只有1个时，
我们直接将这一个圆盘从当前位置移动到目标位置。

否则，我们先将最上面n-1个盘块从当前位置移动到过渡位置，
然后将最下面一个圆盘从当前位置移动到目标位置，
最后将n-1个盘块从过渡位置移动到目标位置。

这样就完成了递归，我们测试一下，输入
Towers(5, "A", "B", "C")

就可以看到我们的每一次的移动过程，大家有兴趣的话可以去验证一下。

目前为止，我们讨论的都是简化后只有一种基础问题的情况，
下面我们一起来看下另一个例子，输出斐波那契数列某一项的数。

斐波那契數列由0和1開始，之後的斐波那契數就是由之前的兩數相加而得出。首幾個斐波那契數是：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……
斐波那契数列中的0表示第0项。

这个例子的有两个基础问题，也就是第0项和第1项，对于其他项，他的数值可以通过它前面两项的值相加得到。

我们在Python中通过递归实现一下。
