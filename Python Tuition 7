上一期，我我们一起学习了两种复合数据类型，元组和列表。
元组是不可以被修改的，而列表是可以被修改的。
这一期，我们一起来学习递归(Recursion)和字典操作(Dictionary)

所谓递归，就是不断地重复同一个操作的过程。
从算法上来讲，递归是将一个规模较大的问题
简化为同样的但是规模较小的问题并解决。

我们先来看一个简单的例子，计算两个数 a和b的乘积：a*b
这个运算等价于我们将 b 个 a 相加，也就是
   a*b 
  =a + a + ... + a. (这里一共有b个a)
 下面我们再将是个表达式做一个简单的变换，
 我们还可以继续写成下面这个形式：
   a*b 
  =a + a + ... + a. (这里一共有b个a)
  =a + (a + ... + a). (这里一共有b个a)
  =a + a*(b-1) 
 也就是先计算 b-1 个 a 相加的结果，再在此基础上加上一个 a
 
 实际上，这就是一个递归的过程，将 b 个a相加的问题
 简化为b-1个a相加的问题，
 这时，我们需要计算 a*(b-1)，我们将这个问题继续简化为
 a+a*(b-2)
 以此类推，直到问题变成最基础的问题，也就是可以直接解决的形式，
 也就是 b=1 时， 此时 a*b = a
 
 我们可以用一个函数来描述这个递归的过程。
 def mult(a, b):
    if b == 1:
        return a
    else:
        return a + mult(a, b-1)
 我们定义函数 mult用递归的方法计算两个数的乘积，
 当 b=1 时，问题简化为最基础的问题，可以直接计算的形式，此时我们返回 a
 否则，我们将问题简化,返回
 a+mult(a+b)
 继续调用递归函数，计算更简单的问题。
 
那么什么样的问题才是最基础的问题呢？
我们再来看一个例子，计算一个给定数的阶乘，n!,我们知道
n! = n*(n-1)*(n-2)* ... *2*1
当 n=1 的时候，n的阶乘就是它本身，所以我们把 n=1作为最基础的问题
当我们用函数实现时，可以写成
def fac(n):
    if n == 1:
        return 1
    else:
        return n*fac(n-1)

 例如我们需要计算并输出3的阶乘，我们可以输入
 print(fac(3))
 
 变量空间的变化

我们再来看一个例子，汉诺塔问题。

有三根杆子A，B，C。A杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：
1. 每次只能移动一个圆盘；
2. 大盘不能叠在小盘上面。
提示：可将圆盘临时置于 B 杆，也可将从 A 杆移出的圆盘重新移回 A 杆，但都必须遵循上述两条规则。

对于这个问题，我们可以用递归的思想解决。

目标是把这些盘全部移到 C 塔。那么先把 A 塔顶部的 N-1 块盘移动到 B 塔，
再把 A 塔剩下的大盘移到 C，最后把 B 塔的N-1块盘移到 C。
至于如何移动N-1快盘，我们可以用相同的方法，
先移动最上面N-2块盘，
如此递归下去。当我们需要移动的顶部盘块中只有一个圆盘时，我就找到了简化的最基础的问题，
此时，我们把这一个圆盘直接移到目标杆，也就是C杆。

下面我们来看一下如何在Python中用代码实现。

def printMove(fr, to):
    print("Move from", str(fr), "to", str(to))
    
def Towers(n, fr, to, spare):
    if n ==1:
        printMove(fr, to)
    else:
        Towers(n-1, fr, spare, to)
        Towers(1, fr, to, spare)
        Towers(n-1, spare, to, fr)
        
首先我们定义一个函数printMove用来输出我们每一步移动的过程
printMove(fr, to)表示将圆盘从fr对应的杆子移动到 to对应的杆子。

然后我们定义递归函数 Towers。函数中有四个参数
第一个位置的参数表示需要移动的圆盘的个数，
第二个位置的参数表示待移动圆盘或圆盘块现在在的位置，我们叫它当前位置，
第三个位置的参数表示目标杆的位置，我们叫它目标目标位置，
最后一个位置的参数表示剩下的一个杆子，我们叫它过渡位置。
首先我们设置基础问题的解，当需要移动的圆盘只有1个时，
我们直接将这一个圆盘从当前位置移动到目标位置。

否则，我们先将最上面n-1个盘块从当前位置移动到过渡位置，
然后将最下面一个圆盘从当前位置移动到目标位置，
最后将n-1个盘块从过渡位置移动到目标位置。

这样就完成了递归，我们测试一下，输入
Towers(5, "A", "B", "C")

就可以看到我们的每一次的移动过程，大家有兴趣的话可以去验证一下。

目前为止，我们讨论的都是简化后只有一种基础问题的情况，
下面我们一起来看下另一个例子，输出斐波那契数列某一项的数。

斐波那契數列由0和1開始，之後的斐波那契數就是由之前的兩數相加而得出。首幾個斐波那契數是：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……
斐波那契数列中的0表示第0项。

这个例子的有两个基础问题，也就是第0项和第1项，对于其他项，他的数值可以通过它前面两项的值相加得到。

我们在Python中通过递归实现一下。
def fib(x):
    """
    input: an int x
    returns Fibonacci of x 
    """
    if x == 0:
        return 0
    elif x ==1:
        return 1
    else:
        return fib(x-1) + fib(x-2)

接下来我们再来看一个例子，用递归判断给定的一串字符串是否是回文序列。
回文序列是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
这里我们不区分大小写。
例如‘Able was I ere I saw Elba’是回文序列，
因为从右向左是‘able was i ere i sawl eba’
如果一个字符串长度为1或者0，那么这个字符串一定是一个回文序列。

要判断一个序列是否是回文序列，我们只需要保证序列左右两端的字符是一样的，
同时去掉左右两端的字符之后的序列也是回文序列。

我们来看一下如何在python中实现
def isPalindrome(s):
    """
    Input Type: String
    Returns True if input string is palindrome,
    Otherwise, returns False
    """
    def toChars(s):
        s = s.lower()
        ans = ''
        for c in s:
            if c in "abcdefghijklmnopqrstuvwxyz":
                ans = ans + c
        return ans
    
    def isPal(s):
        if len(s) <= 1:
            return True
        else:
            return s[0] == s[-1] and isPal(s[1:-1])
    return isPal(toChars(s))

首先，我们定义一个函数来判断给定字符串是否是回序列，
这里我们不区分大小写也不考虑表单符号和运算符。
我们先将给定的序列转化成全部小些且只包含字母的形式。
这个过程我们通过一个子函数实现，
我们使用python自带的函数将s变成全部小写的形式，
s = a.lower(）
然后晒先只保留s中的字母，将转换之后的字符串返回

下面我们再写个子函数实现递归判断，
当序列长度小于等于1时，这个序列就是回文序列。我们返回True
否则，如果s第一个和最后一个字母相同，并且去掉这两个元素之后的序列也是回文序列，
我们就判断s是回文序列，返回True，否则返回False
最后是我们函数的返回，返回 isPal(toChars(s))

我们来运行测试一下：
s = input("Input a string to see if that is palindrome: ")       
if isPalindrome(s):
    print(s, "is PALINDROME!!")
else:
    print(s, "is NOT palindrome.")
    
下面我们再来一起学习另外一种复合数据类型，字典（Dictionary）
有时候我们需要吧一个关键词和一串信息或者数据连接起来，例如
我们希望输入姓名就能看到性别.
John: Male
Mike: Male
Lucy: Female
我们可以创建一个字典存储这些数据
dic = {"John" : "Male", "Mike" : "Male", "Lucy" : "Female" }
使用大括号表示要创建一个字典，字典中元素用逗号隔开，
每个元素包含关键词和关键词的值，关键词与值 之前用冒号隔开，例如
"John" : "Male"

当我们输入
dic["John"]
Python就会返回这个关键词的值字符串"Male"

字典的关键词一般是唯一的，如果重复最后的一个关键词对会替换前面的，值不需要唯一

字典中元素是可以被修改的，例如我们想在字典 dic中添加关键词 "Bob",他的值是"Male"，
只要输入 dic["Bob"] = "Male"
这是字典dic就更新为
 {'John': 'Male', 'Mike': 'Male', 'Lucy': 'Female', 'Bob': 'Male'}
 
 我们还可以判定一个关键词是否在字典里
 例如输入
 "John" in dic
 如 "John"是字典dic的一个关键词，那么就会返回True，否则返回False
 我们还可以删除dic中的元素，例如输入
 del(dic["Mike"])
这是字典dic变为
{'John': 'Male', 'Lucy': 'Female', 'Bob': 'Male'}
我们还可以用
dic.keys()
获取字典dic中所有的关键词，返回是一个列表的形式，列表中包含所有的关键词
如果属于
dic.values()
那么返回的就是所有值组成的一个列表

下面我们对比以一下列表和字典
列表是一系列有序的元素组成
通过一个整数所索引列表的元素
列表中元素是有序的 

字典是一个关键词对应一个值
通过关键词索引
字典中的元素是无序的

我们再回头看一下求斐波那契数列的例子，使用我刚才的算法，每一次输入一个序号，
都要重新计算它前面的每个位置的数据，计算量很大，使用字典，
我们可以将每次计算的结果储存起来，下次再需要计算这个数值的时候可以直接拿来使用。
可以节省很多时间，我们来看一下如何实现

def fib_efficient(n, d):
    """
    Inputs: non-negtive int n and dictionary d.
    Returns the nth fibnonacci
    """
    if n in d:
        return d[n]
    else:
        ans = fib_efficient(n-1, d) + fib_efficient(n-2, d)
        d[n] = ans
    return ans

b = {0:0, 1:1}      #用问题的基础解初始化字典
print(fib_efficient(8,b))


